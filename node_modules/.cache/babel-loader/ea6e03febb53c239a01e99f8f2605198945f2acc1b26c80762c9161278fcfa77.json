{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.releasePointer = exports.lockPointer = void 0;\nvar _handle = require(\"@enact/core/handle\");\nvar active;\nvar capturedDown = false;\n\n// if there is a focused input (there should be) and the target is not the input\nvar shouldCapture = function shouldCapture(_ref) {\n  var target = _ref.target;\n  return active && target !== active;\n};\nvar isCapturing = function isCapturing() {\n  return capturedDown && active;\n};\nvar setCapturing = function setCapturing(capturing) {\n  return (0, _handle.returnsTrue)(function () {\n    return capturedDown = capturing;\n  });\n};\nvar handlePointerDown = (0, _handle.handle)(shouldCapture,\n// If we should capture the click\n_handle.preventDefault,\n// prevent the down event bubbling\n_handle.stop,\n// (and stop propagation to support touch)\nsetCapturing(true) // and flag that we've started capturing a down event\n);\n\nvar handlePointerUp = (0, _handle.handle)(isCapturing,\n// if a down event was captured\n_handle.preventDefault,\n// prevent the up event bubbling\n_handle.stop // (and stop propagation to support touch)\n);\n\n// This is attached to both click and touchend. On some systems (e.g. Chrome), click events are\n// fired when you touch anything but other systems (e.g. iOS) will only emit click events when you\n// touch a clickable component (something with a tabindex). By attaching the same handler to both,\n// we ensure that we do not leave this module in an unstable state where it thinks capturing is\n// active but focus is not on the input.\nvar handleTap = (0, _handle.handle)(isCapturing,\n// if a down event was captured\n_handle.stop,\n// prevent the click event from propagating\n_handle.preventDefault,\n// prevent touchend from triggering a click after releasing lock\nsetCapturing(false),\n// clear the capturing flag\nfunction () {\n  return active.blur();\n} // and blur the active node\n);\n\nvar handleTouchStart = (0, _handle.handle)(shouldCapture,\n// If we should capture the click\n_handle.stop,\n// prevent other components from handling this event\nsetCapturing(true) // and flag that we've started capturing a down event\n);\n\n// Lock the pointer from emitting click events until released\nvar lockPointer = exports.lockPointer = function lockPointer(target) {\n  active = target;\n  document.addEventListener('mousedown', handlePointerDown, {\n    capture: true\n  });\n  document.addEventListener('mouseup', handlePointerUp, {\n    capture: true\n  });\n  document.addEventListener('touchstart', handleTouchStart, {\n    capture: true\n  });\n  document.addEventListener('touchend', handleTap, {\n    capture: true\n  });\n  document.addEventListener('click', handleTap, {\n    capture: true\n  });\n};\n\n// Release the pointer and allow subsequent click events\nvar releasePointer = exports.releasePointer = function releasePointer(target) {\n  if (target === active) {\n    active = null;\n    document.removeEventListener('mousedown', handlePointerDown, {\n      capture: true\n    });\n    document.removeEventListener('mouseup', handlePointerUp, {\n      capture: true\n    });\n    document.removeEventListener('touchstart', handleTouchStart, {\n      capture: true\n    });\n    document.removeEventListener('touchend', handleTap, {\n      capture: true\n    });\n    document.removeEventListener('click', handleTap, {\n      capture: true\n    });\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","releasePointer","lockPointer","_handle","require","active","capturedDown","shouldCapture","_ref","target","isCapturing","setCapturing","capturing","returnsTrue","handlePointerDown","handle","preventDefault","stop","handlePointerUp","handleTap","blur","handleTouchStart","document","addEventListener","capture","removeEventListener"],"sources":["/Users/meogyu/connected_front/node_modules/@enact/sandstone/Input/pointer.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.releasePointer = exports.lockPointer = void 0;\nvar _handle = require(\"@enact/core/handle\");\nvar active;\nvar capturedDown = false;\n\n// if there is a focused input (there should be) and the target is not the input\nvar shouldCapture = function shouldCapture(_ref) {\n  var target = _ref.target;\n  return active && target !== active;\n};\nvar isCapturing = function isCapturing() {\n  return capturedDown && active;\n};\nvar setCapturing = function setCapturing(capturing) {\n  return (0, _handle.returnsTrue)(function () {\n    return capturedDown = capturing;\n  });\n};\nvar handlePointerDown = (0, _handle.handle)(shouldCapture,\n// If we should capture the click\n_handle.preventDefault,\n// prevent the down event bubbling\n_handle.stop,\n// (and stop propagation to support touch)\nsetCapturing(true) // and flag that we've started capturing a down event\n);\nvar handlePointerUp = (0, _handle.handle)(isCapturing,\n// if a down event was captured\n_handle.preventDefault,\n// prevent the up event bubbling\n_handle.stop // (and stop propagation to support touch)\n);\n\n// This is attached to both click and touchend. On some systems (e.g. Chrome), click events are\n// fired when you touch anything but other systems (e.g. iOS) will only emit click events when you\n// touch a clickable component (something with a tabindex). By attaching the same handler to both,\n// we ensure that we do not leave this module in an unstable state where it thinks capturing is\n// active but focus is not on the input.\nvar handleTap = (0, _handle.handle)(isCapturing,\n// if a down event was captured\n_handle.stop,\n// prevent the click event from propagating\n_handle.preventDefault,\n// prevent touchend from triggering a click after releasing lock\nsetCapturing(false),\n// clear the capturing flag\nfunction () {\n  return active.blur();\n} // and blur the active node\n);\nvar handleTouchStart = (0, _handle.handle)(shouldCapture,\n// If we should capture the click\n_handle.stop,\n// prevent other components from handling this event\nsetCapturing(true) // and flag that we've started capturing a down event\n);\n\n// Lock the pointer from emitting click events until released\nvar lockPointer = exports.lockPointer = function lockPointer(target) {\n  active = target;\n  document.addEventListener('mousedown', handlePointerDown, {\n    capture: true\n  });\n  document.addEventListener('mouseup', handlePointerUp, {\n    capture: true\n  });\n  document.addEventListener('touchstart', handleTouchStart, {\n    capture: true\n  });\n  document.addEventListener('touchend', handleTap, {\n    capture: true\n  });\n  document.addEventListener('click', handleTap, {\n    capture: true\n  });\n};\n\n// Release the pointer and allow subsequent click events\nvar releasePointer = exports.releasePointer = function releasePointer(target) {\n  if (target === active) {\n    active = null;\n    document.removeEventListener('mousedown', handlePointerDown, {\n      capture: true\n    });\n    document.removeEventListener('mouseup', handlePointerUp, {\n      capture: true\n    });\n    document.removeEventListener('touchstart', handleTouchStart, {\n      capture: true\n    });\n    document.removeEventListener('touchend', handleTap, {\n      capture: true\n    });\n    document.removeEventListener('click', handleTap, {\n      capture: true\n    });\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}