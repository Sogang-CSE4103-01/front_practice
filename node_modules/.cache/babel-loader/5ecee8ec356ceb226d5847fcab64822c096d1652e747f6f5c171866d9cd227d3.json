{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getNearestTargetFromPosition = void 0;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\nvar _container = require(\"./container\");\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\nvar _utils = require(\"./utils\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    }\n\n    // only verify selector for the first (immediate ancestor) container\n    verifySelector = false;\n  }\n  return true;\n}\nfunction getContainersToSearch(containerId) {\n  var range = [];\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n  return range;\n}\nfunction getTargetByContainer(containerId, enterTo) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id, enterTo);\n  }, null);\n}\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n  var next = (0, _utils.parseSelector)(selector)[0];\n  if (next) {\n    if ((0, _container.isContainer)(next)) {\n      return getTargetByContainer((0, _container.getContainerId)(next));\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n  return null;\n}\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  }\n\n  // remove elements that are outside of boundingRect, if specified\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right;\n\n    // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread(_objectSpread({}, rect), {}, {\n        center: _objectSpread({}, rect.center)\n      });\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n      return updated;\n    }\n    return rect;\n  });\n}\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  });\n\n  // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n  return false;\n}\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop = function _loop() {\n      var overlappingContainerId = getContainerContainingRect(elementRects, positionRect);\n\n      // if the pointer is within a container that is a candidate element, we need to ignore container\n      // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n      if (overlappingContainerId) {\n        next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n        if (!next) {\n          // filter out the container and try again\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element.dataset.spotlightId !== overlappingContainerId;\n          });\n          return 0; // continue\n        }\n\n        // found a target so break out and return\n        return 1; // break\n      }\n\n      // try to navigate from position to one of the candidates in containerId\n      next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId));\n\n      // if we match a container, recurse into it\n      if (next && (0, _container.isContainer)(next)) {\n        var nextContainerId = next.dataset.spotlightId;\n\n        // need to cache this reference so we can filter it out later if necessary\n        var lastNavigated = next;\n        next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n        if (!next) {\n          // filter out the container and try again\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element !== lastNavigated;\n          });\n          return 0; // continue\n        }\n      }\n\n      // If we've met every condition and haven't explicitly retried the search via `continue`,\n      // break out and return\n      return 1; // break\n    },\n    _ret;\n  while (elementRects.length > 0) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret === 1) break;\n  }\n  return next;\n}\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n\n  // shortcut for previous target from element if it were saved\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  }\n\n  // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop2 = function _loop2() {\n      var overlappingContainerId = getContainerContainingRect(elementRects, elementRect);\n\n      // if the next element is a container AND the current element is *visually* contained within\n      // one of the candidate elements, we need to ignore container `enterTo` preferences and\n      // retrieve its spottable descendants and try to navigate to them.\n      if (overlappingContainerId) {\n        next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n        if (!next) {\n          // filter out the container and try again\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element.dataset.spotlightId !== overlappingContainerId;\n          });\n          return 0; // continue\n        }\n\n        // found a target so break out and return\n        return 1; // break\n      }\n\n      // If one of the downstream containers is configured for partition, we use that\n      // container's bounds as the partition rect for navigation.\n      var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {\n        var cfg = (0, _container.getContainerConfig)(id);\n        return cfg && cfg.partition;\n      });\n      var partitionRect = elementRect;\n      if (partitionContainer) {\n        partitionRect = (0, _utils.getContainerRect)(partitionContainer);\n      }\n\n      // try to navigate from element to one of the candidates in containerId\n      next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect);\n\n      // if we match a container,\n      if (next && (0, _container.isContainer)(next)) {\n        var nextContainerId = next.dataset.spotlightId;\n\n        // need to cache this reference so we can filter it out later if necessary\n        var lastNavigated = next;\n\n        // and it is restricted, return its target\n        if (isRestrictedContainer(nextContainerId)) {\n          next = getTargetByContainer(nextContainerId);\n        } else {\n          // otherwise, recurse into it\n          next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n        }\n        if (!next) {\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element !== lastNavigated;\n          });\n          return 0; // continue\n        }\n      }\n\n      // If we've met every condition and haven't explicitly retried the search via `continue`,\n      // break out and return\n      return 1; // break\n    },\n    _ret2;\n  while (elementRects.length > 0) {\n    _ret2 = _loop2();\n    if (_ret2 === 0) continue;\n    if (_ret2 === 1) break;\n  }\n  return next;\n}\nfunction getTargetByDirectionFromElement(direction, element) {\n  var _getContainerConfig;\n  var getIntersectRectOfElem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var extSelector = element.getAttribute('data-spot-' + direction);\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n  var elementContainerId = (0, _container.getContainersForNode)(element).pop();\n  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, getIntersectRectOfElem ? (0, _utils.getIntersectionRect)((0, _container.getContainerNode)(elementContainerId), element) : (0, _utils.getRect)(element), elementContainerIds);\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction);\n\n      // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n      if (result === false) {\n        result = element;\n      }\n    }\n    return result;\n  }, null);\n\n  // If the reduce above returns the original element,\n  // check if the element is clipped by an overflow container. If true, find the target by direction with the intersection rect of the element.\n  // If the reduce above returns the original element again, it means it hit a `leaveFor` config that\n  // prevents navigation so we enforce that here by returning null.\n  if (next !== element) {\n    return next;\n  } else if (elementContainerId !== _container.rootContainerId && (_getContainerConfig = (0, _container.getContainerConfig)(elementContainerId)) !== null && _getContainerConfig !== void 0 && _getContainerConfig.overflow && !getIntersectRectOfElem) {\n    return getTargetByDirectionFromElement(direction, element, true);\n  } else {\n    return null;\n  }\n}\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n      return getTargetBySelector(target);\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n  return null;\n}\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n\n  return target;\n}\nvar getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {\n  var x = _ref.x,\n    y = _ref.y;\n  var left = _ref2.left,\n    right = _ref2.right,\n    top = _ref2.top,\n    bottom = _ref2.bottom;\n  if (direction === 'left' || direction === 'right') {\n    if (y > bottom) {\n      distance += y - bottom;\n    } else if (y < top) {\n      distance += top - y;\n    }\n  } else if (x > right) {\n    distance += x - right;\n  } else if (x < left) {\n    distance += left - x;\n  }\n  return distance;\n};\nvar getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {\n  var x = position.x,\n    y = position.y;\n  var distance;\n  if (direction === 'left') {\n    distance = x - elementRect.right;\n  } else if (direction === 'right') {\n    distance = elementRect.left - x;\n  } else if (direction === 'up') {\n    distance = y - elementRect.bottom;\n  } else if (direction === 'down') {\n    distance = elementRect.top - y;\n  }\n  return getOffsetDistanceToTargetFromPosition((0, _clamp[\"default\"])(0, Math.abs(distance), distance), direction, position, elementRect);\n};\nvar getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {\n  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {\n    var target = getTargetByDirectionFromPosition(direction, position, containerId);\n    if (target) {\n      result.push({\n        direction: direction,\n        target: target\n      });\n    }\n    return result;\n  }, []);\n};\nvar getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {\n  var targets = getNearestTargetsInContainerFromPosition(position, containerId);\n  if (!targets.length) {\n    return;\n  }\n  targets.forEach(function (item) {\n    var direction = item.direction,\n      target = item.target;\n    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));\n  });\n  targets.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return targets[0].target;\n};\nvar getNearestTargetFromPosition = exports.getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {\n  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","getNavigableTarget","getNearestTargetFromPosition","getTargetByContainer","getTargetByDirectionFromElement","getTargetByDirectionFromPosition","getTargetBySelector","isFocusable","_clamp","_interopRequireDefault","require","_last","_container","_navigate","_utils","obj","__esModule","ownKeys","e","r","t","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","key","_toPropertyKey","configurable","writable","i","_toPrimitive","String","Symbol","toPrimitive","call","TypeError","Number","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","minLen","_arrayLikeToArray","n","prototype","toString","slice","constructor","name","Array","from","test","iter","iterator","isArray","len","arr2","elem","containers","getContainersForNode","verifySelector","containerId","isNavigable","getContainersToSearch","range","addRange","id","config","getContainerConfig","indexOf","selectorDisabled","getDefaultContainer","getLastContainer","getAllContainerIds","map","enterTo","reduce","next","getContainerFocusTarget","selector","charAt","substr","parseSelector","isContainer","getContainerId","nextContainerIds","isRestrictedContainer","filterRects","elementRects","boundingRect","rect","element","intersects","contains","center","topUpdate","top","bottomUpdate","bottom","leftUpdate","left","rightUpdate","right","updated","centerX","x","centerY","y","getContainerContainingRect","elementRect","overlapping","dataset","spotlightId","getOverflowContainerRect","nextConfig","overflow","getContainerRect","getTargetInContainerByDirectionFromPosition","direction","positionRect","elementContainerIds","elements","getDeepSpottableDescendants","getRects","_loop","overlappingContainerId","nextContainerId","lastNavigated","_ret","getTargetInContainerByDirectionFromElement","previous","getContainerPreviousTarget","spotlightOverflow","_loop2","partitionContainer","find","cfg","partition","partitionRect","_ret2","_getContainerConfig","getIntersectRectOfElem","undefined","extSelector","getAttribute","elementContainerId","pop","getNavigableContainersForNode","reduceRight","result","index","getIntersectionRect","getContainerNode","getRect","getLeaveForTarget","rootContainerId","position","pointerRect","getPointRect","target","restrict","leaveFor","document","parent","parentNode","getOffsetDistanceToTargetFromPosition","distance","_ref","_ref2","getDistanceToTargetFromPosition","Math","abs","getNearestTargetsInContainerFromPosition","getNearestTargetInContainerFromPosition","targets","item","sort","a","b","elementFromPoint"],"sources":["/Users/meogyu/connected_front/node_modules/@enact/spotlight/src/target.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getNearestTargetFromPosition = void 0;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\nvar _container = require(\"./container\");\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\nvar _utils = require(\"./utils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    }\n\n    // only verify selector for the first (immediate ancestor) container\n    verifySelector = false;\n  }\n  return true;\n}\nfunction getContainersToSearch(containerId) {\n  var range = [];\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n  return range;\n}\nfunction getTargetByContainer(containerId, enterTo) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id, enterTo);\n  }, null);\n}\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n  var next = (0, _utils.parseSelector)(selector)[0];\n  if (next) {\n    if ((0, _container.isContainer)(next)) {\n      return getTargetByContainer((0, _container.getContainerId)(next));\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n  return null;\n}\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  }\n\n  // remove elements that are outside of boundingRect, if specified\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right;\n\n    // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread(_objectSpread({}, rect), {}, {\n        center: _objectSpread({}, rect.center)\n      });\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n      return updated;\n    }\n    return rect;\n  });\n}\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  });\n\n  // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n  return false;\n}\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop = function _loop() {\n      var overlappingContainerId = getContainerContainingRect(elementRects, positionRect);\n\n      // if the pointer is within a container that is a candidate element, we need to ignore container\n      // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n      if (overlappingContainerId) {\n        next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n        if (!next) {\n          // filter out the container and try again\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element.dataset.spotlightId !== overlappingContainerId;\n          });\n          return 0; // continue\n        }\n\n        // found a target so break out and return\n        return 1; // break\n      }\n\n      // try to navigate from position to one of the candidates in containerId\n      next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId));\n\n      // if we match a container, recurse into it\n      if (next && (0, _container.isContainer)(next)) {\n        var nextContainerId = next.dataset.spotlightId;\n\n        // need to cache this reference so we can filter it out later if necessary\n        var lastNavigated = next;\n        next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n        if (!next) {\n          // filter out the container and try again\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element !== lastNavigated;\n          });\n          return 0; // continue\n        }\n      }\n\n      // If we've met every condition and haven't explicitly retried the search via `continue`,\n      // break out and return\n      return 1; // break\n    },\n    _ret;\n  while (elementRects.length > 0) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret === 1) break;\n  }\n  return next;\n}\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n\n  // shortcut for previous target from element if it were saved\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  }\n\n  // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop2 = function _loop2() {\n      var overlappingContainerId = getContainerContainingRect(elementRects, elementRect);\n\n      // if the next element is a container AND the current element is *visually* contained within\n      // one of the candidate elements, we need to ignore container `enterTo` preferences and\n      // retrieve its spottable descendants and try to navigate to them.\n      if (overlappingContainerId) {\n        next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n        if (!next) {\n          // filter out the container and try again\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element.dataset.spotlightId !== overlappingContainerId;\n          });\n          return 0; // continue\n        }\n\n        // found a target so break out and return\n        return 1; // break\n      }\n\n      // If one of the downstream containers is configured for partition, we use that\n      // container's bounds as the partition rect for navigation.\n      var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {\n        var cfg = (0, _container.getContainerConfig)(id);\n        return cfg && cfg.partition;\n      });\n      var partitionRect = elementRect;\n      if (partitionContainer) {\n        partitionRect = (0, _utils.getContainerRect)(partitionContainer);\n      }\n\n      // try to navigate from element to one of the candidates in containerId\n      next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect);\n\n      // if we match a container,\n      if (next && (0, _container.isContainer)(next)) {\n        var nextContainerId = next.dataset.spotlightId;\n\n        // need to cache this reference so we can filter it out later if necessary\n        var lastNavigated = next;\n\n        // and it is restricted, return its target\n        if (isRestrictedContainer(nextContainerId)) {\n          next = getTargetByContainer(nextContainerId);\n        } else {\n          // otherwise, recurse into it\n          next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n        }\n        if (!next) {\n          elementRects = elementRects.filter(function (rect) {\n            return rect.element !== lastNavigated;\n          });\n          return 0; // continue\n        }\n      }\n\n      // If we've met every condition and haven't explicitly retried the search via `continue`,\n      // break out and return\n      return 1; // break\n    },\n    _ret2;\n  while (elementRects.length > 0) {\n    _ret2 = _loop2();\n    if (_ret2 === 0) continue;\n    if (_ret2 === 1) break;\n  }\n  return next;\n}\nfunction getTargetByDirectionFromElement(direction, element) {\n  var _getContainerConfig;\n  var getIntersectRectOfElem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var extSelector = element.getAttribute('data-spot-' + direction);\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n  var elementContainerId = (0, _container.getContainersForNode)(element).pop();\n  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, getIntersectRectOfElem ? (0, _utils.getIntersectionRect)((0, _container.getContainerNode)(elementContainerId), element) : (0, _utils.getRect)(element), elementContainerIds);\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction);\n\n      // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n      if (result === false) {\n        result = element;\n      }\n    }\n    return result;\n  }, null);\n\n  // If the reduce above returns the original element,\n  // check if the element is clipped by an overflow container. If true, find the target by direction with the intersection rect of the element.\n  // If the reduce above returns the original element again, it means it hit a `leaveFor` config that\n  // prevents navigation so we enforce that here by returning null.\n  if (next !== element) {\n    return next;\n  } else if (elementContainerId !== _container.rootContainerId && (_getContainerConfig = (0, _container.getContainerConfig)(elementContainerId)) !== null && _getContainerConfig !== void 0 && _getContainerConfig.overflow && !getIntersectRectOfElem) {\n    return getTargetByDirectionFromElement(direction, element, true);\n  } else {\n    return null;\n  }\n}\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n      return getTargetBySelector(target);\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n  return null;\n}\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n  return target;\n}\nvar getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {\n  var x = _ref.x,\n    y = _ref.y;\n  var left = _ref2.left,\n    right = _ref2.right,\n    top = _ref2.top,\n    bottom = _ref2.bottom;\n  if (direction === 'left' || direction === 'right') {\n    if (y > bottom) {\n      distance += y - bottom;\n    } else if (y < top) {\n      distance += top - y;\n    }\n  } else if (x > right) {\n    distance += x - right;\n  } else if (x < left) {\n    distance += left - x;\n  }\n  return distance;\n};\nvar getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {\n  var x = position.x,\n    y = position.y;\n  var distance;\n  if (direction === 'left') {\n    distance = x - elementRect.right;\n  } else if (direction === 'right') {\n    distance = elementRect.left - x;\n  } else if (direction === 'up') {\n    distance = y - elementRect.bottom;\n  } else if (direction === 'down') {\n    distance = elementRect.top - y;\n  }\n  return getOffsetDistanceToTargetFromPosition((0, _clamp[\"default\"])(0, Math.abs(distance), distance), direction, position, elementRect);\n};\nvar getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {\n  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {\n    var target = getTargetByDirectionFromPosition(direction, position, containerId);\n    if (target) {\n      result.push({\n        direction: direction,\n        target: target\n      });\n    }\n    return result;\n  }, []);\n};\nvar getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {\n  var targets = getNearestTargetsInContainerFromPosition(position, containerId);\n  if (!targets.length) {\n    return;\n  }\n  targets.forEach(function (item) {\n    var direction = item.direction,\n      target = item.target;\n    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));\n  });\n  targets.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return targets[0].target;\n};\nvar getNearestTargetFromPosition = exports.getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {\n  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}