{"ast":null,"code":"const adjustPath = path => {\n  let tmp = path;\n  if (!/^(luna|palm):\\/\\//.test(path)) {\n    tmp = `luna://${path}`;\n  }\n  if (tmp.slice(-1) !== '/') {\n    tmp = `${tmp}/`;\n  }\n  return tmp;\n};\nconst splitAt = index => p => [p.slice(0, index >= 0 ? index : 0), p.slice(index + 1)];\nconst parseLS2Uri = uri => {\n  const [, path] = uri.split('//');\n  const [service] = path.split('/');\n  const pathname = path.slice(path.indexOf('/'));\n  let [category, method] = splitAt(pathname.lastIndexOf('/'))(pathname);\n  category = `${category}/`;\n  return {\n    service,\n    category,\n    method\n  };\n};\nconst getHash = ({\n  service,\n  category,\n  method\n}, params) => {\n  const sig = `${service}${category}${method}${JSON.stringify(params)}`;\n  let hash = 0;\n  if (sig.length === 0) return hash;\n  for (let i = 0; i < sig.length; ++i) {\n    const chr = sig.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n};\n\n// Please add methods not to use hash name.\nconst methods = ['launch'];\nclass LS2Request {\n  send({\n    service = '',\n    method = '',\n    onSuccess = () => {},\n    onFailure = () => {},\n    onComplete = () => {},\n    parameters = {},\n    subscribe = false\n  }) {\n    let params = {\n      ...parameters\n    };\n    const fullUri = `${adjustPath(service)}${method}`;\n    const parsedUri = parseLS2Uri(fullUri);\n    if (subscribe) {\n      params.subscribe = subscribe;\n    }\n    let filepath = `${parsedUri.service}${parsedUri.category}${parsedUri.method}`;\n    if (!methods.includes(method)) {\n      filepath = `${filepath}${getHash(parsedUri, params)}`;\n    }\n    try {\n      const res = require(`../../${filepath}.json`);\n      if (res.errorCode || res.returnValue === false) {\n        onFailure(res);\n      } else {\n        onSuccess(res);\n      }\n      onComplete(res);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.log({\n        service,\n        method,\n        parameters\n      });\n      onFailure(err);\n      onComplete(err);\n    }\n    return this;\n  }\n  cancel() {}\n}\nexport default LS2Request;","map":{"version":3,"names":["adjustPath","path","tmp","test","slice","splitAt","index","p","parseLS2Uri","uri","split","service","pathname","indexOf","category","method","lastIndexOf","getHash","params","sig","JSON","stringify","hash","length","i","chr","charCodeAt","methods","LS2Request","send","onSuccess","onFailure","onComplete","parameters","subscribe","fullUri","parsedUri","filepath","includes","res","require","errorCode","returnValue","err","console","log","cancel"],"sources":["/Users/meogyu/connected_front/__mocks__/@enact/webos/LS2Request.js"],"sourcesContent":["const adjustPath = path => {\n\tlet tmp = path;\n\tif (!/^(luna|palm):\\/\\//.test(path)) {\n\t\ttmp = `luna://${path}`;\n\t}\n\tif (tmp.slice(-1) !== '/') {\n\t\ttmp = `${tmp}/`;\n\t}\n\treturn tmp;\n};\n\nconst splitAt = index => p =>\n\t[p.slice(0, index >= 0 ? index : 0), p.slice(index + 1)];\n\nconst parseLS2Uri = uri => {\n\tconst [, path] = uri.split('//');\n\tconst [service] = path.split('/');\n\tconst pathname = path.slice(path.indexOf('/'));\n\tlet [category, method] = splitAt(pathname.lastIndexOf('/'))(pathname);\n\tcategory = `${category}/`;\n\treturn {service, category, method};\n};\n\nconst getHash = ({service, category, method}, params) => {\n\tconst sig = `${service}${category}${method}${JSON.stringify(params)}`;\n\tlet hash = 0;\n\tif (sig.length === 0) return hash;\n\tfor (let i = 0; i < sig.length; ++i) {\n\t\tconst chr = sig.charCodeAt(i);\n\t\thash = (hash << 5) - hash + chr;\n\t\thash |= 0; // Convert to 32bit integer\n\t}\n\treturn hash;\n};\n\n// Please add methods not to use hash name.\nconst methods = ['launch'];\n\nclass LS2Request {\n\tsend({\n\t\tservice = '',\n\t\tmethod = '',\n\t\tonSuccess = () => {},\n\t\tonFailure = () => {},\n\t\tonComplete = () => {},\n\t\tparameters = {},\n\t\tsubscribe = false\n\t}) {\n\t\tlet params = {...parameters};\n\t\tconst fullUri = `${adjustPath(service)}${method}`;\n\t\tconst parsedUri = parseLS2Uri(fullUri);\n\t\tif (subscribe) {\n\t\t\tparams.subscribe = subscribe;\n\t\t}\n\t\tlet filepath = `${parsedUri.service}${parsedUri.category}${parsedUri.method}`;\n\t\tif (!methods.includes(method)) {\n\t\t\tfilepath = `${filepath}${getHash(parsedUri, params)}`;\n\t\t}\n\t\ttry {\n\t\t\tconst res = require(`../../${filepath}.json`);\n\t\t\tif (res.errorCode || res.returnValue === false) {\n\t\t\t\tonFailure(res);\n\t\t\t} else {\n\t\t\t\tonSuccess(res);\n\t\t\t}\n\n\t\t\tonComplete(res);\n\t\t} catch (err) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.log({service, method, parameters});\n\t\t\tonFailure(err);\n\t\t\tonComplete(err);\n\t\t}\n\t\treturn this;\n\t}\n\tcancel() {}\n}\n\nexport default LS2Request;\n"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,IAAI,IAAI;EAC1B,IAAIC,GAAG,GAAGD,IAAI;EACd,IAAI,CAAC,mBAAmB,CAACE,IAAI,CAACF,IAAI,CAAC,EAAE;IACpCC,GAAG,GAAI,UAASD,IAAK,EAAC;EACvB;EACA,IAAIC,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IAC1BF,GAAG,GAAI,GAAEA,GAAI,GAAE;EAChB;EACA,OAAOA,GAAG;AACX,CAAC;AAED,MAAMG,OAAO,GAAGC,KAAK,IAAIC,CAAC,IACzB,CAACA,CAAC,CAACH,KAAK,CAAC,CAAC,EAAEE,KAAK,IAAI,CAAC,GAAGA,KAAK,GAAG,CAAC,CAAC,EAAEC,CAAC,CAACH,KAAK,CAACE,KAAK,GAAG,CAAC,CAAC,CAAC;AAEzD,MAAME,WAAW,GAAGC,GAAG,IAAI;EAC1B,MAAM,GAAGR,IAAI,CAAC,GAAGQ,GAAG,CAACC,KAAK,CAAC,IAAI,CAAC;EAChC,MAAM,CAACC,OAAO,CAAC,GAAGV,IAAI,CAACS,KAAK,CAAC,GAAG,CAAC;EACjC,MAAME,QAAQ,GAAGX,IAAI,CAACG,KAAK,CAACH,IAAI,CAACY,OAAO,CAAC,GAAG,CAAC,CAAC;EAC9C,IAAI,CAACC,QAAQ,EAAEC,MAAM,CAAC,GAAGV,OAAO,CAACO,QAAQ,CAACI,WAAW,CAAC,GAAG,CAAC,CAAC,CAACJ,QAAQ,CAAC;EACrEE,QAAQ,GAAI,GAAEA,QAAS,GAAE;EACzB,OAAO;IAACH,OAAO;IAAEG,QAAQ;IAAEC;EAAM,CAAC;AACnC,CAAC;AAED,MAAME,OAAO,GAAGA,CAAC;EAACN,OAAO;EAAEG,QAAQ;EAAEC;AAAM,CAAC,EAAEG,MAAM,KAAK;EACxD,MAAMC,GAAG,GAAI,GAAER,OAAQ,GAAEG,QAAS,GAAEC,MAAO,GAAEK,IAAI,CAACC,SAAS,CAACH,MAAM,CAAE,EAAC;EACrE,IAAII,IAAI,GAAG,CAAC;EACZ,IAAIH,GAAG,CAACI,MAAM,KAAK,CAAC,EAAE,OAAOD,IAAI;EACjC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,GAAG,CAACI,MAAM,EAAE,EAAEC,CAAC,EAAE;IACpC,MAAMC,GAAG,GAAGN,GAAG,CAACO,UAAU,CAACF,CAAC,CAAC;IAC7BF,IAAI,GAAG,CAACA,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAGG,GAAG;IAC/BH,IAAI,IAAI,CAAC,CAAC,CAAC;EACZ;EACA,OAAOA,IAAI;AACZ,CAAC;;AAED;AACA,MAAMK,OAAO,GAAG,CAAC,QAAQ,CAAC;AAE1B,MAAMC,UAAU,CAAC;EAChBC,IAAIA,CAAC;IACJlB,OAAO,GAAG,EAAE;IACZI,MAAM,GAAG,EAAE;IACXe,SAAS,GAAGA,CAAA,KAAM,CAAC,CAAC;IACpBC,SAAS,GAAGA,CAAA,KAAM,CAAC,CAAC;IACpBC,UAAU,GAAGA,CAAA,KAAM,CAAC,CAAC;IACrBC,UAAU,GAAG,CAAC,CAAC;IACfC,SAAS,GAAG;EACb,CAAC,EAAE;IACF,IAAIhB,MAAM,GAAG;MAAC,GAAGe;IAAU,CAAC;IAC5B,MAAME,OAAO,GAAI,GAAEnC,UAAU,CAACW,OAAO,CAAE,GAAEI,MAAO,EAAC;IACjD,MAAMqB,SAAS,GAAG5B,WAAW,CAAC2B,OAAO,CAAC;IACtC,IAAID,SAAS,EAAE;MACdhB,MAAM,CAACgB,SAAS,GAAGA,SAAS;IAC7B;IACA,IAAIG,QAAQ,GAAI,GAAED,SAAS,CAACzB,OAAQ,GAAEyB,SAAS,CAACtB,QAAS,GAAEsB,SAAS,CAACrB,MAAO,EAAC;IAC7E,IAAI,CAACY,OAAO,CAACW,QAAQ,CAACvB,MAAM,CAAC,EAAE;MAC9BsB,QAAQ,GAAI,GAAEA,QAAS,GAAEpB,OAAO,CAACmB,SAAS,EAAElB,MAAM,CAAE,EAAC;IACtD;IACA,IAAI;MACH,MAAMqB,GAAG,GAAGC,OAAO,CAAE,SAAQH,QAAS,OAAM,CAAC;MAC7C,IAAIE,GAAG,CAACE,SAAS,IAAIF,GAAG,CAACG,WAAW,KAAK,KAAK,EAAE;QAC/CX,SAAS,CAACQ,GAAG,CAAC;MACf,CAAC,MAAM;QACNT,SAAS,CAACS,GAAG,CAAC;MACf;MAEAP,UAAU,CAACO,GAAG,CAAC;IAChB,CAAC,CAAC,OAAOI,GAAG,EAAE;MACb;MACAC,OAAO,CAACC,GAAG,CAAC;QAAClC,OAAO;QAAEI,MAAM;QAAEkB;MAAU,CAAC,CAAC;MAC1CF,SAAS,CAACY,GAAG,CAAC;MACdX,UAAU,CAACW,GAAG,CAAC;IAChB;IACA,OAAO,IAAI;EACZ;EACAG,MAAMA,CAAA,EAAG,CAAC;AACX;AAEA,eAAelB,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}